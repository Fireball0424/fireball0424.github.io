---
title: 深入淺出 設計模式 Ch1 
date: 2025-05-22 02:20:00 +0800 
categories: [Design Pattern, HeadFirst]
tags: [Note, Design Pattern]
---

:::success
#### 小小的前言
希望能在暑假結束前讀完這本書 - 深入淺出設計模式

對於每一章做小小的整理！
:::

# 設計模式入門

對於一個superclass，繼承不是唯一的答案

可能會有一些function是對於每個child classes 都不一樣的

## 設計原則1 
:::info
將會變化的部分獨立出來
:::

將這些會變化的function放在獨立的class 中

這個class 專門提供某個function API implementation 

``` c++
// 原本來說，一個Class 如下
// 每個 SubClass 都要分開去定義會不會飛/怎麼飛
class Duck(){
    display(); // fix
    fly();     // change 
}


// 將 fly function 分開成獨立的 Class 
// 這樣一來，Duck() 就不需要管 FlyBehavior 的細節
class FlyBehavior(){
    fly();
}

class FlyWithWings(){
    fly(){duck fly}
}
class NoFly(){
    fly(){do nothing}
}
```

## 設計原則2
:::info
Code by Interface

Instead Code by Implementation 
:::

```cpp
// Assume we have class 
class Animal{
    makeSound();
}

class Dog{
    makeSound(){bark();}
}
bark(){/*bark bark */}
class Cat{
    makeSound(){meow();}
}
meow(){/*meow meow */}

// If Code by Implementation 
Dog d = new Dog();
d.bark();

// If Code by Interface 
Animal animal = new Dog();
animal.makeSound();

// Even more (no need to new Dog())
a = getAnimal();
a.makeSound();
```
## 如何使用 Behavior Class 
```cpp
// superclass
class Duck{
    FlyBehavior flyBehavior; 
    // ... 
    void performFly(){
        flyBehavior.fly();
    }
}

// child class 
class GreenDuck: public Duck{
    GreenDuck(){
        flyBehavior = new FlyWithWings(); 
        // 這裡還是 code by implementation, 之後會修改的更好！
    }
}
```

## Dynamic Behavior 

page 56 



